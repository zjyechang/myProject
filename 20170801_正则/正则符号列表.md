<!-- TOC -->

- [RegExp正则表达式 Regular Expression](#regexp正则表达式-regular-expression)
    - [对象定义](#对象定义)
    - [搭配的字符串方法](#搭配的字符串方法)
        - [返回值分类](#返回值分类)
    - [正则对象方法](#正则对象方法)
    - [语法：符号含义](#语法符号含义)
        - [对象修饰符：匹配模式，写在直接量/……/后面](#对象修饰符匹配模式写在直接量后面)
        - [特殊符号](#特殊符号)
        - [字符直接量：预定义字符](#字符直接量预定义字符)
        - [预定义类](#预定义类)
        - [重复（匹配前一项）](#重复匹配前一项)
        - [选择、分组、引用](#选择分组引用)
        - [锚](#锚)
    - [有用的例子](#有用的例子)

<!-- /TOC -->

# RegExp正则表达式 Regular Expression
让计算机读懂人想要表达的规则，用于操纵字符串
## 对象定义
var a=//;//双斜杠内部写表达式

## 搭配的字符串方法
- spilt() 使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中
- indexOf() 寻找字符串首字母的下标，返回下标数字
- search() 在字符串中测试匹配，它返回匹配到的位置索引，或者在失败时返回-1~~过程先把传入的参数转为正则表达式，再进行匹配，不支持修饰符~~
- match() 在字符串中执行查找匹配，它返回一个数组或者在未匹配到时返回null
- replace(str,"") 在字符串中执行查找匹配，并且使用替换字符串替换掉匹配到的子字符串，返回新字符串
这里replace()的第二个参数可以是函数，但是有固定的规则，参见[W3C String对象replace方法](http://www.w3school.com.cn/jsref/jsref_replace.asp)
这个函数的参数是这样的(matchStr,[$1,$2,$3...,]index,inputStr)

### 返回值分类
**字符串方法返回值有三类：**
- 返回数字类型：indexOf，lastIndexOf，search , charCodeAt
- 返回数组的方法：split，match
- 返回字符串的方法：charAt，substring，substr, slice, replace

## 正则对象方法
- exec(str) 用正则字面量去持续查找str,并返回匹配项数组
- test(str) str是否匹配正则字面量，返回是否

## 语法：符号含义
### 对象修饰符：匹配模式，写在直接量/……/后面
- g 全局模式global
- i 不区分大小写case-insensitive,忽略模式与字符串的大小写
- m 多行multiline
### 特殊符号
- ^ 1.开头,并且如有多行，也包括换行符后 2.否定(在)
- $ 结尾，并且如有多行，也包括换行符前
- . 除换行回车之外的任意单字符
- \* 0次或者更多，相当于{0,}
- \+ 1次或者更多，相当于{1,}
- ? 1.重复0或1次，相当于{0,1} 2.如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反
- =
- ! 没有含义
- :
- | 或,匹配左表达式或者右表达式
- \ 转义*\\后面出现字母时，如果不是预定义字符或者其他有意义字符，它就转义成一个字符边界*
- / 正则字面量的开始和结束
- () 捕获括号，用于包括一个捕获组，可以用\1,\2,\3引用不同的括号里的子表达式所匹配的项，数字代表左括号的序号从1开始
- (?:) 非捕获括号，用于单纯的包含一个表达式，不记忆它的匹配项
- {}
- [] 字符类，如[a-zA-Z0-9]

### 字符直接量：预定义字符
- \t 制表符，tab(\u0009)
- \n 换行符(\u000A),或者将数字（0-7）转义为八进制
- \v 垂直制表符(\u000B)
- \f 换页符(\u000C)
- \r 回车符(\u000D)
- \xnn 由十六进制数nn指定的拉丁字符，如\x0A等价于\n
- \unnnn 由十六进制数nn指定的Unicode字符，如\u0009等价于\t
- \cX 控制字符^X，如\cJ等价于\n，X的范围是A-Z
- *\0 匹配NULL(U+0000)字符，不要在这后面跟其它小数，因为 \0<digits> 是一个八进制转义序列*

### 预定义类
- \w 任何单词字符，等价于字母加数字加下划线_
- \W \w取反
- \s Unicode空白符，*注意，不是空格，而是等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]*
- \S \s取反
- \d 数字
- \D \d取反
- [\b] 退格

**[\u4e00-\u9fa5] 中文集合**

### 重复（匹配前一项）
- {n,m} 至少n次，不超过m次
- {n,} 至少n次或更多
- {n} n次
- ？ 0次或者1次，相当于{0,1}
- + 1次或者更多，相当于{1,}
- * 0次或者更多，相当于{0,}

### 选择、分组、引用
- | 左表达式或者右表达式
- () 括号分组
- (?:...) 分组，并且不生成引用
- \x 与第x分组第一次匹配的字符匹配

### 锚
- ^ 开头
- $ 结尾
- \b 单词边界，给一个特例，/\w\b\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着
- \B 不是边界（单词的边界），例如/\B../匹配"noonday"中得'oo', 而/y\B./匹配"possibly yesterday"中得’ye‘
- (?=pattern) 零宽先行断言，用于占据一个位置，这个位置可以是或者不可以是某些值。pattern用于描述锚之后的要求，其中=号要求：接下来的字符与pattern匹配；例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。
- (?!pattern) 而！号要求：接下来的字符都不与pattern匹配。但真正的匹配项都是不包括这些字符的，这些字符仅仅用于断言，所以是“零宽”

##有用的例子
1. 将用户输入的正则表达式转成可以创建RegExp对象的字符串
var a=prompt("输入要查询的正则表达式");
        console.log(escapeRegExp(a));
        function escapeRegExp(string){
            return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$&"); 
            //$&表示整个被匹配的字符串
        }

2. 双引号转为单引号
replace(/"([^"]*)"/g, "'$1'")

3. 所有单词首字母大写
replace(/\b\w+\b/g,function(word){
    return word.substring(0,1).toUpperCase()+word.substring(1);

});