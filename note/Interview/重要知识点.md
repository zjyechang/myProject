# 移动端的兼容问题
1. input的placeholder偏上的问题，
解决： 设置line-height:normal
2. 一些情况下对非点击元素（span，label）监听click事件无效
解决：添加cursor:pointer
3. Safari position设置fixed问题
解决：添加-webkit-overflow-scroll:touch
4. 点击穿透问题
解决：用fastclick插件，全部都用click事件，或者设置pointer-events为none，添加动画300ms
5. 输入框在最底层时，弹起的虚拟键盘会遮挡住输入框
Element.scrollIntoViewIfNeeded(opt_center)


# Web前端优化
1. 尽量减少HTTP请求 (Make Fewer HTTP Requests)
2. 减少 DNS 查找 (Reduce DNS Lookups)
3. 避免重定向 (Avoid Redirects)
4. 使得 Ajax 可缓存 (Make Ajax Cacheable)
5. 延迟载入组件 (Post-load Components)
6. 预载入组件 (Preload Components)
7. 减少 DOM 元素数量 (Reduce the Number of DOM Elements)
8. 切分组件到多个域 (Split Components Across Domains)
9. 最小化 iframe 的数量 (Minimize the Number of iframes)
10. 杜绝 http 404 错误 (No 404s)

# mvvm
将View和逻辑分离出来,由一个 ViewModel 的视图的绑定属性，并可获得二者之间的松散耦合，所以需要在ViewModel 直接更新视图中编写相应代码
优点：
1. 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
2. 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
3. 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。
4. 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

# get 和 post区别
1. 幂等性
2. GET产生的URL地址可以被Bookmark，而POST不可以。
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
4. GET请求只能进行url编码，而POST支持多种编码方式。
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
6. GET请求在URL中传送的参数是有长度限制的，而POST没有。
7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
9. GET参数通过URL传递，POST放在Request body中
10. get只传送一次请求，post先传header通过后再传data

# 事件环

# I/O非阻塞

# macroTask 机制

# webpack配置
在webpack.config里面添加需要打包的插件模块

# 虚拟DOM

# 怎么使用代理？
本地client=>config=>index=>proxyTable里面设置
服务器端，设置nginx反向代理
client=>config=>api.config.js=>

const isPro = Object.is(process.env.NODE_ENV, 'production')
module.exports = {
  baseUrl: isPro ? 'http://shop.zjyechang.top/api' : 'api/'
}


# es6常用
let,const  
rest剩余...  
default默认值function( a='asda'){}  
解构赋值  
class,extends,super  
箭头函数  
模板字符串，反引号（``）来标识起始，用${}来引用变量


# 判断是不是数组的方法
1. arr.constructor.name==='Array' 或者 arr.constructor===Array  
2. arr instanceof Array
3. Array.isArray(arr)  
4. Object.prototype.toString.call( arr ) === '[object Array]'; 
5. 通过一些数组独有的方法判断是否数组。比如join,push等